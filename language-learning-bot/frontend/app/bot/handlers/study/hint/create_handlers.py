"""
Handlers for hint creation.
"""

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext

from app.utils.api_utils import get_api_client_from_bot
from app.utils.logger import setup_logger
from app.utils.error_utils import validate_state_data
from app.utils.state_models import UserWordState, HintState
from app.utils.word_data_utils import ensure_user_word_data
from app.utils.hint_constants import get_all_hint_types, get_hint_key, get_hint_name
from app.bot.handlers.study.study_states import HintStates, StudyStates
from app.bot.handlers.study.study_words import show_study_word

# –°–æ–∑–¥–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω—ã–π —Ä–æ—É—Ç–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–æ–∫
create_router = Router()

# Set up logging
logger = setup_logger(__name__)

@create_router.callback_query(F.data.startswith("hint_create_"))
async def process_hint_create(callback: CallbackQuery, state: FSMContext):
    """
    Process callback when user wants to create a new hint.
    
    Args:
        callback: The callback query from Telegram
        state: The FSM state context
    """
    # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π callback_data –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    logger.info(f"Received callback_data: {callback.data}")
    
    # –°–Ω–∞—á–∞–ª–∞ –≤—ã–¥–µ–ª—è–µ–º –¥–≤–∞ –ø–µ—Ä–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ (hint_create)
    prefixes = callback.data.split('_', 2)
    if len(prefixes) < 3:
        await callback.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
        return
    
    # –¢–µ–ø–µ—Ä—å —Ä–∞–∑–±–∏—Ä–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω—É—é —á–∞—Å—Ç—å —Å—Ç—Ä–æ–∫–∏
    remainder = prefixes[2]  # "phonetic_association_ID" –∏–ª–∏ "meaning_ID"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–∞–∫–æ–π —Ç–∏–ø –ø–æ–¥—Å–∫–∞–∑–∫–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ remainder
    hint_type = None
    word_id = None
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ —Ç–∏–ø–∞ –ø–æ–¥—Å–∫–∞–∑–∫–∏
    for possible_type in get_all_hint_types():
        print(possible_type, prefixes)
        if remainder.startswith(possible_type + "_"):
            hint_type = possible_type
            word_id = remainder[len(possible_type) + 1:]  # –í—Å—ë –ø–æ—Å–ª–µ "TYPE_"
            break
    
    if not hint_type or not word_id:
        logger.error(f"Could not parse callback_data: {callback.data}")
        await callback.answer("–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–∫–∏")
        return
    
    logger.info(f"Parsed callback_data: action=create, hint_type={hint_type}, word_id={word_id}")
    
    # Validate state data
    is_valid, state_data = await validate_state_data(
        state, 
        ["current_word", "db_user_id"],
        callback,
        "–û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏"
    )
    
    if not is_valid:
        return
    
    # Get current word and user ID
    current_word = state_data["current_word"]
    db_user_id = state_data["db_user_id"]
    
    # Check if word_id matches current word
    current_word_id = None
    for id_field in ["id", "_id", "word_id"]:
        if id_field in current_word and current_word[id_field]:
            current_word_id = str(current_word[id_field])
            # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ, –ø—Ä–µ—Ä—ã–≤–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É
            if current_word_id == word_id:
                break
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    logger.info(f"Comparing word IDs: callback_word_id={word_id}, current_word_id={current_word_id}")
    logger.info(f"Current word fields: {[k for k in current_word.keys() if k in ['id', '_id', 'word_id']]}")
    
    if not current_word_id or current_word_id != word_id:
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É —Å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
        logger.error(f"Word ID mismatch: callback_word_id={word_id}, available IDs in current_word: "
                    f"id={current_word.get('id')}, _id={current_word.get('_id')}, word_id={current_word.get('word_id')}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—à–∏–±–∫—É —á–µ—Ä–µ–∑ alert, –∞ –Ω–µ –ø—Ä–æ—Å—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await callback.answer("–û—à–∏–±–∫–∞: –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ID —Å–ª–æ–≤–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å–ª–æ–≤–æ.")
        return
    
    # Get hint key and name
    hint_key = get_hint_key(hint_type)
    hint_name = get_hint_name(hint_type)
    
    if not hint_key or not hint_name:
        await callback.answer("–û—à–∏–±–∫–∞: –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ø–æ–¥—Å–∫–∞–∑–∫–∏")
        return
    
    # Create hint state
    hint_state = HintState(
        hint_key=hint_key,
        hint_name=hint_name,
        hint_word_id=word_id
    )
    
    # Save to state
    await hint_state.save_to_state(state)
    await state.set_state(HintStates.creating)
    
    # Get word info for display
    word_foreign = current_word.get("word_foreign")
    transcription = current_word.get("transcription", "")
    translation = current_word.get("translation", "")
    
    # Ask for hint text
    await callback.message.answer(
        f"–°–ª–æ–≤–æ: <code>{word_foreign}</code>\n\n"
        f"–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è: <b>[{transcription}]</b>\n\n"
        f"–ü–µ—Ä–µ–≤–æ–¥:\n<b>{translation}</b>\n\n"
        f"üìù –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ —Ç–∏–ø–∞ ¬´{hint_name}¬ª\n\n"
        f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø–æ–¥—Å–∫–∞–∑–∫–∏,\n"
        f"–∏–ª–∏ –∑–∞–ø–∏—à–∏—Ç–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ,\n"
        f"–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã:",
        parse_mode="HTML",
    )
    
    await callback.answer()

@create_router.message(HintStates.creating)
async def process_hint_text(message: Message, state: FSMContext):
    """
    Process the hint text entered by the user as text or voice message.
    
    Args:
        message: The message object from Telegram
        state: The FSM state context
    """
    # Load hint state from FSM
    hint_state = await HintState.from_state(state)
    
    # Validate hint state
    if not hint_state.is_valid():
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.")
        return
    
    # Load user word state for db_user_id and current_word
    user_word_state = await UserWordState.from_state(state)
    
    # Validate user word state
    if not user_word_state.is_valid():
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –∏–ª–∏ —Å–ª–æ–≤–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.")
        return
    
    # Get hint text from message
    hint_text = None
    
    if message.text:
        # –ï—Å–ª–∏ –ø–æ–ª—É—á–µ–Ω–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        hint_text = message.text

        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—Ö–∞ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–π –ø–æ–¥—Å–∫–∞–∑–∫–∏
        await message.answer(
            f"‚úÖ –ü–æ–¥—Å–∫–∞–∑–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!\n\n"
            f"¬´{hint_state.hint_name}¬ª\n\n"
            f"–¢–µ–∫—Å—Ç –ø–æ–¥—Å–∫–∞–∑–∫–∏:\n<code>{hint_text}</code>\n\n"
            "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∏–∑—É—á–µ–Ω–∏–µ —Å–ª–æ–≤...",
            parse_mode="HTML",
        )
    elif message.voice:
        # –ï—Å–ª–∏ –ø–æ–ª—É—á–µ–Ω–æ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        processing_msg = await message.answer("üéôÔ∏è –†–∞—Å–ø–æ–∑–Ω–∞—é –≤–∞—à–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...")
        
        try:
            # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥—É–ª—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
            from app.utils.voice_recognition import process_telegram_voice
            
            # –†–∞—Å–ø–æ–∑–Ω–∞–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            recognized_text = await process_telegram_voice(message.bot, message.voice)
            
            if recognized_text:
                hint_text = recognized_text
                # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
                await processing_msg.delete()
                # –£–≤–µ–¥–æ–º–ª—è–µ–º –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ
                await message.answer(
                    f"‚úÖ –ü–æ–¥—Å–∫–∞–∑–∫–∞ —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞ –∏–∑ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è!\n\n"
                    f"¬´{hint_state.hint_name}¬ª\n\n"
                    f"–¢–µ–∫—Å—Ç –ø–æ–¥—Å–∫–∞–∑–∫–∏:\n<code>{recognized_text}</code>\n\n"
                    "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∏–∑—É—á–µ–Ω–∏–µ —Å–ª–æ–≤...",
                    parse_mode="HTML",
                )
            else:
                await processing_msg.delete()
                await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                return
        except ImportError:
            logger.error("Voice recognition module not available")
            await processing_msg.delete()
            await message.answer("‚ùå –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç.")
            return
        except Exception as e:
            logger.error(f"Error processing voice message: {e}", exc_info=True)
            await processing_msg.delete()
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç.")
            return
    else:
        await message.answer("‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
        return
    
    # –û—Å—Ç–∞–≤—à–∞—è—Å—è –ª–æ–≥–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏ (—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥)
    update_data = {hint_state.hint_key: hint_text}
    
    success, result = await ensure_user_word_data(
        message.bot,
        user_word_state.user_id,
        hint_state.hint_word_id,
        update_data,
        user_word_state.word_data,
        message
    )
    
    if not success:
        return
    
    # Update current word data in state with new hint
    if user_word_state.word_data:
        # If user_word_data exists, update there
        user_word_data = user_word_state.word_data.get("user_word_data", {})
        if not user_word_data:
            user_word_state.word_data["user_word_data"] = {}
            
        user_word_state.word_data["user_word_data"][hint_state.hint_key] = hint_text
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã—Ö
        used_hints = user_word_state.get_flag("used_hints", [])
        hint_type = hint_state.get_hint_type()
        if hint_type and hint_type not in used_hints:
            used_hints.append(hint_type)
            user_word_state.set_flag("used_hints", used_hints)
                
    # Return to studying state
    await state.set_state(StudyStates.studying)
    await show_study_word(message, state)

@create_router.callback_query(F.data.startswith("edit_recognized_"))
async def process_edit_recognized(callback: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.
    
    Args:
        callback: The callback query from Telegram
        state: The FSM state context
    """
    # –ü–∞—Ä—Å–∏–º callback_data: edit_recognized_TYPE_ID
    parts = callback.data.split('_', 2)
    if len(parts) < 3:
        await callback.answer("–û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –∑–∞–ø—Ä–æ—Å–∞")
        return
    
    # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —á–∞—Å—Ç–µ–π callback_data
    remainder = parts[2]  # "TYPE_ID"
    
    # –ù–∞–π–¥–µ–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –º–µ–∂–¥—É —Ç–∏–ø–æ–º –∏ ID
    for possible_type in get_all_hint_types():
        if remainder.startswith(possible_type + "_"):
            hint_type = possible_type
            word_id = remainder[len(possible_type) + 1:]  # –í—Å—ë –ø–æ—Å–ª–µ "TYPE_"
            break
    else:
        await callback.answer("–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –ø–æ–¥—Å–∫–∞–∑–∫–∏")
        return
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    is_valid, state_data = await validate_state_data(
        state, 
        ["current_word", "db_user_id"],
        callback,
        "–û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏"
    )
    
    if not is_valid:
        return
    
    # Get current word and user ID
    current_word = state_data["current_word"]
    db_user_id = state_data["db_user_id"]
    
    # –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á –∏ –∏–º—è –ø–æ–¥—Å–∫–∞–∑–∫–∏
    hint_key = get_hint_key(hint_type)
    hint_name = get_hint_name(hint_type)
    
    if not hint_key or not hint_name:
        await callback.answer("–û—à–∏–±–∫–∞: –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ø–æ–¥—Å–∫–∞–∑–∫–∏")
        return
    
    # Get current hint text
    current_hint_text = await get_hint_text(
        callback.bot, 
        db_user_id, 
        word_id, 
        hint_key, 
        current_word
    )
    
    # Create hint state
    hint_state = HintState(
        hint_key=hint_key,
        hint_name=hint_name,
        hint_word_id=word_id,
        current_hint_text=current_hint_text
    )
    
    # Save to state
    await hint_state.save_to_state(state)
    await state.set_state(HintStates.editing)
    
    # Get word info for display
    word_foreign = current_word.get("word_foreign")
    transcription = current_word.get("transcription", "")
    translation = current_word.get("translation", "")
    
    # Prepare message text for editing
    await callback.message.edit_text(
        f"üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞\n\n"
        f"–°–ª–æ–≤–æ: <b>{word_foreign}</b>\n"
        f"–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è: <b>[{transcription}]</b>\n"
        f"–ü–µ—Ä–µ–≤–æ–¥:\n<b>{translation}</b>\n\n"
        f"–ü–æ–¥—Å–∫–∞–∑–∫–∞ <b>¬´{hint_name}¬ª</b>\n\n"
        f"<code>{current_hint_text}</code>\n\n"
        f"üìã –ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ç–µ–∫—Å—Ç, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å.\n"
        f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
        parse_mode="HTML"
    )
    
    await callback.answer()
    